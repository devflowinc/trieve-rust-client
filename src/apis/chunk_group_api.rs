/*
 * Trieve API
 *
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.10.9
 * Contact: developers@trieve.ai
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`add_chunk_to_group`]
#[derive(Clone, Debug)]
pub struct AddChunkToGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group to add the chunk to as a bookmark
    pub group_id: String,
    /// JSON request payload to add a chunk to a group (bookmark it)
    pub add_chunk_to_group_data: models::AddChunkToGroupData
}

/// struct for passing parameters to the method [`add_chunk_to_group_by_tracking_id`]
#[derive(Clone, Debug)]
pub struct AddChunkToGroupByTrackingIdParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group to add the chunk to as a bookmark
    pub tracking_id: String,
    /// JSON request payload to add a chunk to a group (bookmark it)
    pub add_chunk_to_group_data: models::AddChunkToGroupData
}

/// struct for passing parameters to the method [`create_chunk_group`]
#[derive(Clone, Debug)]
pub struct CreateChunkGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to cretea a chunkGroup
    pub create_chunk_group_req_payload: models::CreateChunkGroupReqPayload
}

/// struct for passing parameters to the method [`delete_chunk_group`]
#[derive(Clone, Debug)]
pub struct DeleteChunkGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group you want to fetch.
    pub group_id: String,
    /// Delete the chunks within the group
    pub delete_chunks: bool
}

/// struct for passing parameters to the method [`delete_group_by_tracking_id`]
#[derive(Clone, Debug)]
pub struct DeleteGroupByTrackingIdParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Tracking id of the chunk_group to delete
    pub tracking_id: String,
    /// Delete the chunks within the group
    pub delete_chunks: bool
}

/// struct for passing parameters to the method [`get_chunk_group`]
#[derive(Clone, Debug)]
pub struct GetChunkGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group you want to fetch.
    pub group_id: String
}

/// struct for passing parameters to the method [`get_chunks_in_group`]
#[derive(Clone, Debug)]
pub struct GetChunksInGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group you want to fetch.
    pub group_id: String,
    /// The page of chunks to get from the group
    pub page: Option<i64>
}

/// struct for passing parameters to the method [`get_chunks_in_group_by_tracking_id`]
#[derive(Clone, Debug)]
pub struct GetChunksInGroupByTrackingIdParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// The id of the group to get the chunks from
    pub group_tracking_id: String,
    /// The page of chunks to get from the group
    pub page: i64
}

/// struct for passing parameters to the method [`get_group_by_tracking_id`]
#[derive(Clone, Debug)]
pub struct GetGroupByTrackingIdParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// The tracking id of the group to fetch.
    pub tracking_id: String
}

/// struct for passing parameters to the method [`get_groups_chunk_is_in`]
#[derive(Clone, Debug)]
pub struct GetGroupsChunkIsInParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to get the groups that a chunk is in
    pub get_groups_for_chunks_data: models::GetGroupsForChunksData
}

/// struct for passing parameters to the method [`get_groups_for_dataset`]
#[derive(Clone, Debug)]
pub struct GetGroupsForDatasetParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// The id of the dataset to fetch groups for.
    pub dataset_id: String,
    /// The page of groups to fetch. Page is 1-indexed.
    pub page: i64
}

/// struct for passing parameters to the method [`get_recommended_groups`]
#[derive(Clone, Debug)]
pub struct GetRecommendedGroupsParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to get recommendations of chunks similar to the chunks in the request
    pub recommend_group_chunks_request: models::RecommendGroupChunksRequest
}

/// struct for passing parameters to the method [`remove_chunk_from_group`]
#[derive(Clone, Debug)]
pub struct RemoveChunkFromGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Id of the group you want to remove the chunk from.
    pub group_id: String,
    /// JSON request payload to remove a chunk from a group
    pub remove_chunk_from_group_req_payload: models::RemoveChunkFromGroupReqPayload
}

/// struct for passing parameters to the method [`search_over_groups`]
#[derive(Clone, Debug)]
pub struct SearchOverGroupsParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to semantically search over groups
    pub search_over_groups_data: models::SearchOverGroupsData
}

/// struct for passing parameters to the method [`search_within_group`]
#[derive(Clone, Debug)]
pub struct SearchWithinGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to semantically search a group
    pub search_within_group_data: models::SearchWithinGroupData
}

/// struct for passing parameters to the method [`update_chunk_group`]
#[derive(Clone, Debug)]
pub struct UpdateChunkGroupParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// JSON request payload to update a chunkGroup
    pub update_chunk_group_data: models::UpdateChunkGroupData
}

/// struct for passing parameters to the method [`update_group_by_tracking_id`]
#[derive(Clone, Debug)]
pub struct UpdateGroupByTrackingIdParams {
    /// The dataset id to use for the request
    pub tr_dataset: String,
    /// Tracking id of the chunk_group to update
    pub tracking_id: String,
    /// JSON request payload to update a chunkGroup
    pub update_group_by_tracking_id_req_payload: models::UpdateGroupByTrackingIdReqPayload
}


/// struct for typed successes of method [`add_chunk_to_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddChunkToGroupSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`add_chunk_to_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddChunkToGroupByTrackingIdSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChunkGroupSuccess {
    Status200(models::ChunkGroup),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChunkGroupSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupByTrackingIdSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunkGroupSuccess {
    Status200(models::ChunkGroup),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_chunks_in_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunksInGroupSuccess {
    Status200(models::BookmarkData),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_chunks_in_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunksInGroupByTrackingIdSuccess {
    Status200(models::BookmarkData),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupByTrackingIdSuccess {
    Status200(models::ChunkGroup),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_groups_chunk_is_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupsChunkIsInSuccess {
    Status200(Vec<models::BookmarkGroupResult>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_groups_for_dataset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupsForDatasetSuccess {
    Status200(models::GroupData),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_recommended_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecommendedGroupsSuccess {
    Status200(Vec<models::GroupScoreChunk>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`remove_chunk_from_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveChunkFromGroupSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`search_over_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOverGroupsSuccess {
    Status200(models::SearchOverGroupsResults),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`search_within_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchWithinGroupSuccess {
    Status200(models::SearchWithinGroupResults),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChunkGroupSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupByTrackingIdSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_chunk_to_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddChunkToGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_chunk_to_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddChunkToGroupByTrackingIdError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChunkGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChunkGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupByTrackingIdError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunkGroupError {
    Status400(models::ErrorResponseBody),
    Status404(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_chunks_in_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunksInGroupError {
    Status400(models::ErrorResponseBody),
    Status404(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_chunks_in_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChunksInGroupByTrackingIdError {
    Status400(models::ErrorResponseBody),
    Status404(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupByTrackingIdError {
    Status400(models::ErrorResponseBody),
    Status404(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_groups_chunk_is_in`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupsChunkIsInError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_groups_for_dataset`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupsForDatasetError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_recommended_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRecommendedGroupsError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_chunk_from_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveChunkFromGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_over_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchOverGroupsError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_within_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchWithinGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_chunk_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChunkGroupError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_by_tracking_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupByTrackingIdError {
    Status400(models::ErrorResponseBody),
    UnknownValue(serde_json::Value),
}


/// Route to add a chunk to a group. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn add_chunk_to_group(configuration: &configuration::Configuration, params: AddChunkToGroupParams) -> Result<ResponseContent<AddChunkToGroupSuccess>, Error<AddChunkToGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_id = params.group_id;
    let add_chunk_to_group_data = params.add_chunk_to_group_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/chunk/{group_id}", local_var_configuration.base_path, group_id=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&add_chunk_to_group_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<AddChunkToGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<AddChunkToGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to add a chunk to a group by tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn add_chunk_to_group_by_tracking_id(configuration: &configuration::Configuration, params: AddChunkToGroupByTrackingIdParams) -> Result<ResponseContent<AddChunkToGroupByTrackingIdSuccess>, Error<AddChunkToGroupByTrackingIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let tracking_id = params.tracking_id;
    let add_chunk_to_group_data = params.add_chunk_to_group_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/tracking_id/{tracking_id}", local_var_configuration.base_path, tracking_id=crate::apis::urlencode(tracking_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&add_chunk_to_group_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<AddChunkToGroupByTrackingIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<AddChunkToGroupByTrackingIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn create_chunk_group(configuration: &configuration::Configuration, params: CreateChunkGroupParams) -> Result<ResponseContent<CreateChunkGroupSuccess>, Error<CreateChunkGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let create_chunk_group_req_payload = params.create_chunk_group_req_payload;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&create_chunk_group_req_payload);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<CreateChunkGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<CreateChunkGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn delete_chunk_group(configuration: &configuration::Configuration, params: DeleteChunkGroupParams) -> Result<ResponseContent<DeleteChunkGroupSuccess>, Error<DeleteChunkGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_id = params.group_id;
    let delete_chunks = params.delete_chunks;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/{group_id}", local_var_configuration.base_path, group_id=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("delete_chunks", &delete_chunks.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteChunkGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteChunkGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a chunk_group with the given tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn delete_group_by_tracking_id(configuration: &configuration::Configuration, params: DeleteGroupByTrackingIdParams) -> Result<ResponseContent<DeleteGroupByTrackingIdSuccess>, Error<DeleteGroupByTrackingIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let tracking_id = params.tracking_id;
    let delete_chunks = params.delete_chunks;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/tracking_id/{tracking_id}", local_var_configuration.base_path, tracking_id=crate::apis::urlencode(tracking_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("delete_chunks", &delete_chunks.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<DeleteGroupByTrackingIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<DeleteGroupByTrackingIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the group with the given id. get_group
pub async fn get_chunk_group(configuration: &configuration::Configuration, params: GetChunkGroupParams) -> Result<ResponseContent<GetChunkGroupSuccess>, Error<GetChunkGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_id = params.group_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/{group_id}", local_var_configuration.base_path, group_id=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetChunkGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetChunkGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
pub async fn get_chunks_in_group(configuration: &configuration::Configuration, params: GetChunksInGroupParams) -> Result<ResponseContent<GetChunksInGroupSuccess>, Error<GetChunksInGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_id = params.group_id;
    let page = params.page;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/{group_id}/{page}", local_var_configuration.base_path, group_id=crate::apis::urlencode(group_id), page=page.unwrap());
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetChunksInGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetChunksInGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
pub async fn get_chunks_in_group_by_tracking_id(configuration: &configuration::Configuration, params: GetChunksInGroupByTrackingIdParams) -> Result<ResponseContent<GetChunksInGroupByTrackingIdSuccess>, Error<GetChunksInGroupByTrackingIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_tracking_id = params.group_tracking_id;
    let page = params.page;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/tracking_id/{group_tracking_id}/{page}", local_var_configuration.base_path, group_tracking_id=crate::apis::urlencode(group_tracking_id), page=page);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetChunksInGroupByTrackingIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetChunksInGroupByTrackingIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the group with the given tracking id. get_group_by_tracking_id
pub async fn get_group_by_tracking_id(configuration: &configuration::Configuration, params: GetGroupByTrackingIdParams) -> Result<ResponseContent<GetGroupByTrackingIdSuccess>, Error<GetGroupByTrackingIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let tracking_id = params.tracking_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/tracking_id/{tracking_id}", local_var_configuration.base_path, tracking_id=crate::apis::urlencode(tracking_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupByTrackingIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupByTrackingIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to get the groups that a chunk is in.
pub async fn get_groups_chunk_is_in(configuration: &configuration::Configuration, params: GetGroupsChunkIsInParams) -> Result<ResponseContent<GetGroupsChunkIsInSuccess>, Error<GetGroupsChunkIsInError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let get_groups_for_chunks_data = params.get_groups_for_chunks_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/chunks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&get_groups_for_chunks_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupsChunkIsInSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupsChunkIsInError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch the groups which belong to a dataset specified by its id.
pub async fn get_groups_for_dataset(configuration: &configuration::Configuration, params: GetGroupsForDatasetParams) -> Result<ResponseContent<GetGroupsForDatasetSuccess>, Error<GetGroupsForDatasetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let dataset_id = params.dataset_id;
    let page = params.page;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dataset/groups/{dataset_id}/{page}", local_var_configuration.base_path, dataset_id=crate::apis::urlencode(dataset_id), page=page);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetGroupsForDatasetSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetGroupsForDatasetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.
pub async fn get_recommended_groups(configuration: &configuration::Configuration, params: GetRecommendedGroupsParams) -> Result<ResponseContent<GetRecommendedGroupsSuccess>, Error<GetRecommendedGroupsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let recommend_group_chunks_request = params.recommend_group_chunks_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/recommend", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&recommend_group_chunks_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<GetRecommendedGroupsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<GetRecommendedGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Route to remove a chunk from a group. Auth'ed user or api key must be an admin or owner of the dataset's organization to remove a chunk from a group.
pub async fn remove_chunk_from_group(configuration: &configuration::Configuration, params: RemoveChunkFromGroupParams) -> Result<ResponseContent<RemoveChunkFromGroupSuccess>, Error<RemoveChunkFromGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let group_id = params.group_id;
    let remove_chunk_from_group_req_payload = params.remove_chunk_from_group_req_payload;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/chunk/{group_id}", local_var_configuration.base_path, group_id=crate::apis::urlencode(group_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&remove_chunk_from_group_req_payload);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<RemoveChunkFromGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<RemoveChunkFromGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
pub async fn search_over_groups(configuration: &configuration::Configuration, params: SearchOverGroupsParams) -> Result<ResponseContent<SearchOverGroupsSuccess>, Error<SearchOverGroupsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let search_over_groups_data = params.search_over_groups_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/group_oriented_search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&search_over_groups_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<SearchOverGroupsSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<SearchOverGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
pub async fn search_within_group(configuration: &configuration::Configuration, params: SearchWithinGroupParams) -> Result<ResponseContent<SearchWithinGroupSuccess>, Error<SearchWithinGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let search_within_group_data = params.search_within_group_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&search_within_group_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<SearchWithinGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<SearchWithinGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn update_chunk_group(configuration: &configuration::Configuration, params: UpdateChunkGroupParams) -> Result<ResponseContent<UpdateChunkGroupSuccess>, Error<UpdateChunkGroupError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let update_chunk_group_data = params.update_chunk_group_data;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&update_chunk_group_data);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateChunkGroupSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateChunkGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update a chunk_group with the given tracking id. Auth'ed user or api key must have an admin or owner role for the specified dataset's organization.
pub async fn update_group_by_tracking_id(configuration: &configuration::Configuration, params: UpdateGroupByTrackingIdParams) -> Result<ResponseContent<UpdateGroupByTrackingIdSuccess>, Error<UpdateGroupByTrackingIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let tr_dataset = params.tr_dataset;
    let tracking_id = params.tracking_id;
    let update_group_by_tracking_id_req_payload = params.update_group_by_tracking_id_req_payload;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/chunk_group/tracking_id/{tracking_id}", local_var_configuration.base_path, tracking_id=crate::apis::urlencode(tracking_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("TR-Dataset", tr_dataset.to_string());
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("Authorization", local_var_value);
    };
    local_var_req_builder = local_var_req_builder.json(&update_group_by_tracking_id_req_payload);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        let local_var_entity: Option<UpdateGroupByTrackingIdSuccess> = serde_json::from_str(&local_var_content).ok();
        let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Ok(local_var_result)
    } else {
        let local_var_entity: Option<UpdateGroupByTrackingIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

